# 객체 분해
사람의 기억 방식에도 많은 양을 한꺼번에 저장해서 불러오는게 아니고, 특징만 남기고 세부 사항은
단순화해서 다루는 정보의 수를 줄인대요. 이런게 **추상화** 라는 거죠.  

일반적인 추상화 방법으로는 큰 문제를 쪼개서 나누는 **분해(decomposition)** 라는게
있어요.

## 01 프로시저 추상화와 데이터 추상화
프로시저와 추상화라고 두 가지를 얘기하는데, 객체의 요소인 "행동"과 "속성" 으로 이해할 수
있는 것 같아요.  
**객체 지향(Object Oriented)**은 데이터를 중심으로 **프로시저 추상화(Procedure
Abstraction)** 하는 것이고, 더 크게는 **기능 분해(Function Decomposition)**
이라고 본다네요.

## 02 프로시저 추상화와 기능 분해
기능 분해 방법으로 **하향식 접근법(Top-Down Approach)** 은 최상위 기능에서 부터 점점
작은 단위로 하위 기능까지 분해하는 방법이에요.

급여 관리 시스템으로로 본다면

- 직원의 급여를 계산한다.

라는 최상위 메인 프로시저가 있고,

- 직원의 급여를 계산한다.
  - 사용자로부터 소득세율을 입력 받는다. 
  - 직원의 급여를 계산한다.
  - 양식에 맞게 결과를 출력한다.

이렇게 하위 기능이 있을 수 있는데, 원하는 만큼 계속 하위 기능을 계속 분해하는 거에요.

- 직원의 급여를 계산한다.
  - 사용자로부터 소득세율을 입력 받는다.
    - "세율을 입력하세요: " 라는 문장을 화면에 출력한다.
    - 키보드를 통해서 세율을 입력받는다.
  - 직원의 급여를 계산한다.
    - 전역 변수에 저장된 직원의 기본급 정보를 얻는다.
    - 급여를 계산한다.
  - 양식에 맞게 결과를 출력한다.
    - "이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다.
    
이제 이 내용으로 시스템을 구현해 보는건 생략할게요.

### 하향식 기능 분해의 문제점

#### 하나의 메인 함수라는 비현실적인 아이디어
시스템은 시간이 지나고 사용자의 만족을 위해 새로운 요구사항을 도출해나가면서 지속적으로 기능을
추가하게 되는데, 이건 하나의 메인 함수를 쓰는 개념하곤 모순되는 거겠죠.

#### 메인 함수의 빈번한 재설계
새로운 기능이 추가되면 매번 메인 함수를 손봐야하고, 그렇게 건드리게 되면 부수효과나 버그가
생길 가능성도 높아지겠죠.

#### 비지니스 로직과 사용자 인터페이스의 결합
사용자 인터페이스 부분과 비지니스 로직은 변경의 빈도가 다르다는 거에요. 그런데 일단 메인
함수에 입력을 받는 부분과 로직이 엉켜 있어요. __관심사의 분리__ 를 이룰 수 없게 되어있어요.

#### 성급하게 결정된 실행순서
무엇(what)을 하는지 보다는 어떻게(how) 하는지에 집중하게 해요. 이전에도 배웠듯이
**결합도** 를 높이는 원인이 되는 거에요.

#### 데이터 변경으로 인한 파급효과
어떤 데이터를 어떤 함수가 사용하고 있는지 추적하기가 까다롭네요. 함수 안에서 전역적으로
사용되는 데이터가 여러 기능 내에서 사용되고 변경되기 때문에, 관리가 어려운거죠.

### 언제 하향식 분해가 유용한가?
너무 까서 쓸모 없는 녀석인 줄 알았더니, __이미 해결된 알고리즘을 문서화하고 서술__ 할 때는
좋다고 하는군요.

## 03 모듈성

### 정보 은닉과 모듈
**정보 은닉(information hiding)** 은 시스템을 모듈 단위로 분해하기 위한 기본
원리인데요, 자주 변경되는 부분을 덜 변경되어 안정적인 인터페이스 뒤로 감춰야 하는게
핵심인거죠.

- **복잡성** : 모듈이 복잡하면 이해하고 사용기 어렵기 때문에 외부에 추상화 할 수 있는
  인터페이스를 제공하는게 좋대요.
- **변경 가능성** : 잦은 변경이 있을 때는 구현을 분리해서 경계를 짓는 인터페이스를 주는
  거죠.

### 모듈의 장점과 한계

#### 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.

#### 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.

#### 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다.


## 04 데이터 추상화와 추상 데이터 타입

### 추상 데이터 타입

프로시저 추상화의 한계를 인지하고 대안을 탐색해서 바바라 리스코프 옹께서 **데이터
추상화(Data Abstraction)** 의 개념을 제시하셨더랬어요.

- 타입 정의를 선언 할 수 있어야 하고,
- 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 하고,
- 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 하고,
- 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다고

추상 데이터 타입을 구현하는 프로그래밍 언어의 특성을 말하는 건데, 자바는 다 갖춘게 아닌가
싶었던 차에...  
지은이 역시 추상 데이터 타입으로 클래스는 적합한지 질문 하네요.

## 05 클래스
### 클래스는 추상 데이터 타입인가?
명확한 의미에서 클래스와 추상 데이터 타입은 동일하지 않다는군요. 핵심적인 차이로 클래스는
상속과 다형성을 지원하는데 비해 추상 데이터 타입은 그렇지 못하다는 거래요.

### 변경을 기준으로 선택하라
> 단순히 클래스를 구현 단위로 사용한다는 것이 객체지향 프로그래밍을 한다는 것을 의미하지는
> 않는다. 타입을 기준으로 절차를 추상화하지 않았다면 그것은 객체지향 분해가 아니다. 비록
> 클래스를 사용하고 있더라도 말이다.

멋진 말인 것 같아요.  
객체 지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체해요.

조건문을 사용하는 방식을 기피하는 이유는 **변경** 때문이죠.  
기존 코드에 영향이 없이 새로운 객체 유형과 행위를 추가 할 수 있는게 **개방 폐쇄 원칙(Open
Closed Principle, OCP)** 이에요.  

설계는 변경과 관련된 것이에요.

### 협력이 중요하다
객체 지향에서 중요한 것은 역할, 책임, 협력 이에요. 객체 지향은 기능을 수행하기 위해 객체들이
협력하는 방식에 집중하죠. 협력이라는 문맥을 고려하지 않고 
방식을 타입별로 분배하는 것은 올바르지 않다고 해요.
