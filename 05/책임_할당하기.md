# 책임 할당하기

## 01 책임 주도 설계를 향해

### 데이터보다 행동을 먼저 결정하라

### 협력이라는 문맥 안에서 책임을 결정하라

### 책임 주도 설계
- 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악하고
- 그것을 더 작은 작은 책임으로 분할하고
- 수행하기 적절한 객체나 역할을 찾아 책임 할당을 하고
- 수행 도중 다른 객체의 도움이 필요하면 또 적절한 객체나 역할을 찾고
- 그렇게 찾은 객체나 역할에게 책임을 할당하면서 서로 협력하게 하는 거.

## 02 책임 할당을 위한 GRASP 패턴
"GRASP(General Responsibility Assignment Software Pattern) 일반적인 책임을 위한 소프트웨어 패턴" 이란게 있군요.

### 도메인 개념에서 출발하기
> 올바른 도메인 모델 이란건 존재하지 않는대요.
> 가장 실용적이고 유용한 모델이 답이라는데....

### 정보 전문가에게 책임을 할당하라
> **INFORMATION EXPERT 패턴**  
> 책임을 수행하는데 필요한 정보를 가지고 있는 객체에게 책임을 주어라는데,
> 그러면 응집력 있고 결합도를 낮출 수 있다고 해요.

### 높은 응집도와 낮은 결합도
설계는 수많은 Trade-off 을 연속이죠. 여러 대안 중에 선택을 해야한다면 **LOW COUPLING** 과 **HIGH COHESION** 을 꼽는게 좋아요.

> **LOW COUPLING 패턴**  
> 설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하라는 하나 마나한 소리를 하네요.

> **HIGH COHESION 패턴**  
> 복잡성을 관리할거면 높은 응집도를 유지할 수 있게 책임을 할당하라는.... 이또한 이미 이름으로 의미를 가지는데 부연 설명은 껍질에 불과한 느낌이네요.

### 창조자에게 객체 생성 책임을 할당하라

> **CREATOR 패턴**  
> A객체를 생성 할 때, 알맞은 B객체를 선별하는 건
> - B가 A객체를 포함하고 있거나
> - B가 A객체를 기록한다거나
> - B가 A객체를 긴밀히 사용하거나
> - B가 A객체를 초기화할 수 있는 데이터를 가지고 있는 게 좋다고 해요.

## 03 구현을 통한 검증
> **클래스 응집도 판단하기**  
> - 클래스가 하나 이상의 이유로 변경돼야 한다면 응집도가 낮은 것. 변경의 이유를 기준으로 클래스를 분리.
> - 클래스 인스턴스를 초기화 할 때, 서로다른 속성들이 뭉쳐있다면 낮은 것. 초기화되는 속성의 그룹을 기준으로 클래스를 분리.
> - 메소드 그룹이 속성 그룹을 사용하는 여부로 나뉜다면 응집도가 낮은 것. 이들 그룹을 기준으로 클래스를 분리.

### 타입을 통해 분리하기

### 다형성을 통해 분리하기

### 변경으로부터 보호하기
> **PROTECTED VARIATIONS 패턴**  
> 변경 가능성이 높다면 캡슐화 하여라고 해요.

> **도메인의 구조가 코드의 구조를 이끈다**  
> 구현을 가이드 할 수 있는 도메인 모델을 선택하라고 하면서, 영화예매에서 할인 정책과 할인 조건이 변경될 수 있다는 직관에 의해 추상화 설계를 한것 처럼 자연스럽게 도메인을 쫓아 간다는 거네요.

### 변경과 유연성

## 04 책임 주도 설계의 대안

일단 설계는 어렵다고 지은이도 말했어요. 데이터 지향적으로 일단 만들고 **리팩토링(Refactoring)** 을 통해서 객체 지향적으로 바꾸는 것도 방법이라고 소개해요.

### 메서드 응집도
하나의 메서드에 왕창 때려 넣어 **몬스터 메서드** 를 만들어 놓고 차차 리팩토링 해요. 작은 단위 단위로 메서드를 쪼개요. 메서드 명칭은 간결하지만 의미 깊게. 작지만 풍부하게. 빠르지만 완벽하게.... ㅠ

### 객체를 자율적으로 만들자

