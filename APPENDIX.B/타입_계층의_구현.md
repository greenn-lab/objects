# 타입 계층의 구현

## 클래스를 이용한 타입 계층 구현
타입과 클래스가 다른 의미죠.
그런데도 객체지향 언어에서 클래스를 **사용자 정의 타입(user-defined data type)** 이라고
부르는 이유는 타입은 결국 객체의 퍼블릭 인터페이스를 가리키니까 객체를 생성하는 방법이 클래스니까...  
~~이것도 역시 말의 꼬리잡기 같은건가...~~

## 인터페이스를 이용한 타입 계층 구현
클래스와 타입의 차이점을 이해하는 것은 설계 관점에서 매우 중요해요.  
타입은 퍼블릭 인터페이스를 가진 객체의 범주이고, 클래스는 타입에 속하는 객체들을 구현하기 위한 매커니즘이래요.

객체 지향의 중심은 클래스에 있는게 아니라, 타입에 있다고 해요. 한마디로 객체의 행동과 메세지 전송을 어떻게 하느냐가 중요한
거란거죠. 이걸 지은이는 타입을 중심으로 객체의 계층을 설계하는 거라고 말하네요.

## 추상화 클래스를 이용한 타입 계층 구현
상속을 사용하는 의도를 말하는데, 심장을 저격하는 문구가 있네요.
> `Phone` 은 상속을 염두에 두고 설계된 것이 아니다. (중략)  
> `Phone` 에는 미래의 확장을 위한 어떤 준비도 돼 있지 않다. 사실 `NightlyDiscountPhone` 의 개발자가
> `Phone` 의 코드를 재사용하기 위해 상속을 사용한 것은 트릭에 가깝다.

라며, 현실적인 얘기를 하네요. 남의 코드를 상속한다는게 사실 캡슐화 돼 있는 걸 뒤져보고(decompile 이나
sourcemap 을 뒤져보고) 의도를 파악한 후 가져다 쓰곤 했으니까요. 그러면 나중에 부모 클래스 개발자는 상속을 당한(?)
듯한 느낌을 받을 수 있다는...

## 추상 클래스와인터페이스 결합하기
다중 상속을 위해서는 다중 인터페이스를 쓸 수 밖에 없는데, 문제점은 비슷한 코드가 남발되는 경향이 있다는 거죠. java8
이후로는 default method(이게 공식적인 명칭인지는 모르겠으나) 를 인터페이스에 정의할 수 있어 조금 나아졌지만,
어쨌거나 추상 클래스로 코드 중복을 방지 해요. 이런 방식에도 이름이 있었네요. ~~역시 이름 잘 짓는 사람이 개발도 잘한다는
말은 진리?!!!~~  
**골격 구현 추상 클래스(skeletal implementation abstract class)** 래요.

## 덕 타이핑 사용하기
오리 검사(Duck test)를 하는 거죠.
> 어떤 새가 오리처럼 걷고, 오리처럼 헤엄치며, 오리처럼 꽥꽥 소리를 낸다면 이새를 오리라고 부를 것이다
> - James Whitcom Riley

어떤 대상의 행동이 오리와 같다면 그것을 오리라는 타입으로 취금해도 무방하다는 거에요.  
객체지향 적으로 해석 해보면서 객체가 어떤 인터페이스에 정의 된 행동을 수행할 수 있다면 그 객체를 해당 타입으로 분류해도 된다는
거죠.

근데 대부분의 정적타입 언어는 덕 타이핑을 지원 안한대요.

```java
interface Employee {
    Money calculatePay(double taxRate);
}

@AllArgsConstructor
class SalariedEmployee {
    private String name; 
    private Money basePay;
    
    public Money calculatePay(double taxRate) {
        return basePay.minus(basePay.times(taxRate));
    }
}

@AllArgsConstructor
class HourlyEmployee {
    private String name;
    private Money basePay;
    private int timeCard;
    
    public Money calculatePay(double taxRate) {
        return basePay.times(timeCard)
            .minus(basePay.times(timeCard).times(taxRate));
    }
}
```
같은 시그니처의 메서드가 있는데도 하나의 타입이 될 수 없는거죠.명시적으로 `implements Employee` 를 해줘야만
하나의 타입이 될 수 있어요.

동적 타입 언어의 종류인 루비에서는 메서드의 시그니처가 동일한 클래스들은 하나의 타입으로 간주해 준대요.  
개발하는 당사자도 모르게 하나의 타입이 되어진다... 일단 루비를 모르는 입장에서는 난감할 것 같기도 하면서도, 우리 인간이라는
객체나 우리 인간이 다루는 객체들을 보면 명시적으로 grouping 을 해놓지 않아도 필요할 때 분류를 하면서 몰랐거나 생각해보지
않았던 것들을 하나의 타입이라고 묶기도 하니까, 오히려 더 객체지향적 이란 생각도 드네요.

역시 더 진보적인 언어라는 C#도 `dynamic` 키워드를 이용해서 덕 타이핑을 지원하는 걸 보면 좋은 거라고 판단되네요.
어쨌든 뭐, 목표는 결합도를 낮추고 확장성을 높이고, 유지보수를 용이하게 하자는 거니까.

## 믹스인과 타입 계층
말 그대로 믹스인은 섞는 건데, 객체지향에서는 중복 코드를 줄이는 거겠네요.  
스칼라의 `trait` 을 얘기 많이 들었어요. 스칼라 좋아하는 개발자가 자랑 많이 하는게 그거라서...

어쨌든 java 에서 interface 의 default method 의 탄생 배경을 처음 알았네요.  
코드 중복을 제거하기 위한 게 아니고, 버전이 올라가면서 interface 에 새로운 오퍼레이션이 추가되면 해당 구현 클래스들에게
호환성을 보장하려고 했다고...

하위 타입에 따라서 불필요하게 오퍼레이션이 생기는 경우가 있겠지만 크게 무방할까 싶었는데...  
이게 LSP, 리스코프 치환 원칙을 잘 이해 못해서 생긴 걸 수 있다는 지적이.. 똬~~~
